---
layout: post
title: 와일드카드 (알고스팟 문제 ID:WILDCARD)
subtitle: 알고리즘 문제풀이
tags: [개발,알고리즘,동적계획법]
comments: true
---    


## 문제

와일드카드는 다양한 운영체제에서 파일 이름의 일부만으로 파일 이름을 지정하는 방법이다. 와일드카드 문자열은 일반적인 파일명과 같지만, * 나 ? 와 같은 특수 문자를 포함한다.

와일드카드 문자열을 앞에서 한 글자씩 파일명과 비교해서, 모든 글자가 일치했을 때 해당 와일드카드 문자열이 파일명과 매치된다고 하자. 단, 와일드카드 문자열에 포함된 ? 는 어떤 글자와 비교해도 일치한다고 가정하며, * 는 0 글자 이상의 어떤 문자열에도 일치한다고 본다.

예를 들어 와일드 카드 he?p 는 파일명 help 에도, heap 에도 매치되지만, helpp 에는 매치되지 않는다. 와일드 카드 *p* 는 파일명 help 에도, papa 에도 매치되지만, hello 에는 매치되지 않는다.

와일드카드 문자열과 함께 파일명의 집합이 주어질 때, 그 중 매치되는 파일명들을 찾아내는 프로그램을 작성하시오.

## 입력

입력의 첫 줄에는 테스트 케이스의 수 C (1 <= C <= 10) 가 주어진다. 각 테스트 케이스의 첫 줄에는 와일드카드 문자열 W 가 주어지며, 그 다음 줄에는 파일명의 수 N (1 <= N <= 50) 이 주어진다. 그 후 N 줄에 하나씩 각 파일명이 주어진다. 파일명은 공백 없이 알파벳 대소문자와 숫자만으로 이루어져 있으며, 와일드카드는 그 외에 * 와 ? 를 가질 수 있다. 모든 문자열의 길이는 1 이상 100 이하이다.

## 출력

각 테스트 케이스마다 주어진 와일드카드에 매치되는 파일들의 이름을 한 줄에 하나씩 아스키 코드 순서(숫자, 대문자, 소문자 순)대로 출력한다.

## 예제 입력

>2  
>he?p  
>3  
>help  
>heap  
>helpp  
>*p*  
>3  
>help  
>papa  
>hello  

## 예제 출력
>heap  
>help  
>help  
>papa  

## 풀이 소스코드  
<script src="https://gist.github.com/overflow218/6a97cbe611ba7960c0420fbd6bd2ba78.js"></script>

## 문제 설명
처음 문제를 접하면 어 이거 뭐지? 하고 당황할 수 있는 문제이다. 그럴때는 시간이 오래걸리더라도 확실하게 풀 수 있는 단순한 방법(brute force)이 있는지 생각해 보는 것이 좋다. 쉽게 시도해볼만한 풀이는 와일드카드와 파일명을 한글자씩 확인해보는 것이다. 그래서 서로 같은 글자라면 각각 다음 글자로 넘어가고, 다른 글자라면 멈추면 된다. 그런데 와일드카드에 ? 만 있다면 좀 더 수월했을 문제인데, * 가 있어서 몇 글자에 대응해야 할지 상당히 까다롭다. 이럴때는 가능한 모든 경우를 해보는 수 밖에 없다. 와일드카드와 파일명을 비교할 때 가능한 경우는 다음과 같다.  
1. 와일드카드의 모든 글자를 대응한 경우 -> 파일명도 모든 글자를 대응했으면 가능, 아니면 불가능
2. 파일명의 모든 글자를 대응한 경우 -> 남은 와일드카드의 글자가  * 만 있다면 가능, 아니면 불가능
3. 와일드카드의 글자가 ? 인 경우 -> ?는 아무글자든 1글자에 대응되니까 다음 글자로 넘어가면 된다. 
4. 와일드카드의 글자가 * 인 경우 -> *  는 0 ~ 원하는 개수 만큼의 글자와 대응될 수 있으니 가능한 방법마다 와일드카드를 넘기고, 다시 재귀적으로 반복해주면 된다. 
5. 와일드카드와 파일명이 서로 다른 글자인 경우 -> 무조건 불가능    
6. 와일드카드와 파일명이 서로 같은 글자인 경우 -> 다음 글자로 넘어가면 된다.   

이제 실제 함수로 구현만 하면 된다. 하지만 주어진 인풋이 문자열이기때문에 함수의 인자로 무엇을 넣어야할지에 대해 고민해보아야 한다. 일단 주어진 그대로 문자열을 넣어주는 방법이 있다. 물론 포인터로 연산해서 구현하면 어렵게라도 구현은 할 수 있겠지만, 이 문제의 경우 * 로 인해서 중복되는 부분 문제가 굉장히 많다.(몇글자나 대응시켜야 하는지 모르기 때문에 일단 가능한 모든 경우를 해보아야 하기 때문) 그런데 포인터가 인자로 주어지는 경우, 메모이제이션을 적용하기가 어렵다.(이 또한 방법이 없는 건 아니지만, 효율적인 방법은 아니다)  
다음으로는 string 형식으로 넣어주는 방법이 있는데, 매번 함수를 호출할때마다 substr함수를 써서 스트링을 잘라주어야 하므로 상당히 불편하다. 이 방법 또한 메모이제이션을 적용하기가 어렵다. 
다음으로는 iterator 반복자를 사용하는 방법이 있는데, * 가 나온 경우 몇 개의 글자에 대응해야할지 알기 어려우므로 다른 재귀호출에 영향을 미치지 않도록 반복자를 보존하기가 상당히 까다롭다. 메모이제이션 또한 어렵다.
이때 활용할 수 있는 방법이 인덱스와 문자열을 대응시키는 방법이다. 인덱스를 정해주면 그 인덱스부터 문자열 끝까지로 이어지는 유일한 부분문자열을 구할 수 있다. 쉽게말하면 원래 문자열의 접미사를 구할 수 있는데, 매번 첫글자만 비교하면 되므로 위에서 구한 경우마다 글자를 비교하기가 편하다. 또한 메모이제이션을 사용하여 중복되는 문제를 해결하기도 용이하다. 이번 문제에서는 인덱스를 인수로 넣어주도록하자.  
동적계획법 문제를 풀 때 중복되는 부분문제들을 어떻게 해결할지가 참 어려운 부분이다. 우리는 이를 해결하기 위해 메모이제이션(memoization)을 활용하는데, 문제마다 주어지는 인풋값이 다르므로 적절히 변환하여 메모이제이션을 활용하기 편하게 만들어주어야 한다. 이번 문제에서는 인풋이 문자열로 주어졌지만, 이를 인덱스와 대응시켜 메모이제이션을 용이하게 했다. 물론 이런 방법이 문제를 보자마자 생각난다면 좋겠지만, 그렇지 않다면 다양한 문제를 풀어보면서 비슷한 문제가 나왔을 때 해결할 수 있도록 사고의 발전 과정을 잘 익혀두자. ~~많이 맞아본 놈이 때릴 줄도 안다. ~~  

## 문제 출처  

<a href="https://www.algospot.com/judge/problem/read/WILDCARD"> 문제 링크 </a>
