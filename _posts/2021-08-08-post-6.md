---
layout: post
title: 최대 증가 부분 수열 (알고스팟 문제 ID:LIS)
subtitle: 알고리즘 문제풀이
tags: [개발,알고리즘]
comments: true
---    

## 문제

어떤 정수 수열에서 0개 이상의 숫자를 지우면 이 수열의 부분 수열 (subsequence) 를 얻을 수 있다. 예를 들어 10 7 4 9 의 부분 수열에는 7 4 9, 10 4, 10 9 등이 있다. 단, 10 4 7 은 원래 수열의 순서와 다르므로 10 7 4 9 의 부분 수열이 아니다.

어떤 부분 수열이 순증가할 때 이 부분 수열을 증가 부분 수열 (increasing subsequence) 라고 한다. 주어진 수열의 증가 부분 수열 중 가장 긴 것의 길이를 계산하는 프로그램을 작성하라.

어떤 수열의 각 수가 이전의 수보다 클 때, 이 수열을 순증가 한다고 한다.

## 입력

입력의 첫 줄에는 테스트 케이스의 수 C (<= 50) 가 주어진다. 각 테스트 케이스의 첫 줄에는 수열에 포함된 원소의 수 N (<= 500) 이 주어진다. 그 다음 줄에 수열이 N개의 정수가 주어진다. 각 정수는 1 이상 100,000 이하의 자연수이다.

## 출력

각 테스트케이스마다 한 줄씩, 주어진 수열의 가장 긴 증가 부분 수열의 길이를 출력한다.

## 예제 입력

3  
4  
1 2 3 4  
8  
5 4 3 2 1 6 7 8   
8  
5 6 7 8 1 2 3 4  

## 예제 출력

4  
4  
4  


## 풀이 소스코드  
<script src="https://gist.github.com/overflow218/b89da7f39748eb6d3d3cbe6a77ccf6cc.js"></script>

## 문제 설명
대표적인 동적계획법 문제 중 하나인 최대 증가 부분 수열 문제이다. 처음 문제를 보고 막막할 땐, 단순하게 풀 수 있는 방법이 있는지 생각해보자. 
S[i]부터 시작하는 LIS의 크기를 생각해보자. 맨 처음 원소가 S[i]이니 다음으로 올 수 있는 후보는 S[i] < S[next]이고 i < next를 만족하는 모든 next들이다.
다시 재귀적으로 S[next]에서 시작하는 LIS의 크기를 구하고, 그중에서 가장 큰 값을 가지는 next를 골라주면 S[i]에서부터 시작하는 LIS은 거기에 1을 더해서 구할 수 있다. 
이 생각을 바탕으로 코드를 짜보자. S[i]에서 시작하는 LIS의 크기는 정해져 있다. 그래서 cache값에 그값을 저장해주면, 중첩되는 부분문제 없이 문제를 효율적으로 해결할 수 있다. 
위의 문제풀이는 O(n ^ 2)의 시간이 걸리는 풀이인데, O(nlogn)의 풀이도 가능하다. 아이디어만 설명하자면 다음과 같다. 주어진 수열의 맨처음부터 시작해서 lis의 마지막 원소보다 
현재 원소가 더 크면 이어 붙여주고, 작다면 현재 lis 상에서 들어가야할 위치를 갱신해주는 방법이다. 말로 설명하면 어려우니 예제와 함께 살펴보자  
주어진 수열: 4 5 1 2 3 
4일때 -> 4  (lis가 비어있었으니 그냥 넣어준다.)   
5일때 -> 4 5 (4보다 5가 크니까 이어 붙인다.)    
1일때 -> 1 5 (1은 4보다 작으니까 4대신 넣는다.)  
2일때 -> 1 2 (2는 1보다 크고 5보다 작으니 5자리에 넣어준다.)  
3일때 -> 1 2 3 (2보다 3이 크니까 이어 붙인다.)  
이러한 방법을 쓰면 n개의 원소가 주어졌을때, n개의 원소를 살펴봐야하고, 매 원소마다 이분탐색을 통해 들어갈 위치를 구해줘야하니 O(n) * O(logn) = O(nlogn)의 풀이가 가능하다.

## 문제 출처  

<a href="https://www.algospot.com/judge/problem/read/LIS"> 문제 링크 </a>
