---
layout: post
title: 합친 lis (알고스팟 문제 ID:JLIS)
subtitle: 알고리즘 문제풀이
tags:[개발,알고리즘,동적계획법]
comments: true
---    

## 문제
어떤 수열에서 0개 이상의 숫자를 지운 결과를 원 수열의 부분 수열이라고 부릅니다. 예를 들어 '4 7 6'은 '4 3 7 6 9'의 부분 수열입니다. 중복된 숫자가 없고 오름 차순으로 정렬되어 있는 부분 수열들을 가리켜 증가 부분 수열이라고 부르지요. 예를 들어 '3 6 9'는 앞의 수열의 증가 부분 수열입니다.

두 개의 정수 수열 A 와 B 에서 각각 증가 부분 수열을 얻은 뒤 이들을 크기 순서대로 합친 것을 합친 증가 부분 수열이라고 부르기로 합시다. 이 중 가장 긴 수열을 합친 LIS(JLIS, Joined Longest Increasing Subsequence)이라고 부릅시다. 예를 들어 '1 3 4 7 9' 은 '1 9 4' 와 '3 4 7' 의 JLIS입니다. '1 9' 와 '3 4 7' 을 합쳐 '1 3 4 7 9'를 얻을 수 있기 때문이지요.

A 와 B 가 주어질 때, JLIS의 길이를 계산하는 프로그램을 작성하세요.

## 입력

입력의 첫 줄에는 테스트 케이스의 수 c ( 1 <= c <= 50 ) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 A 와 B 의 길이 n 과 m 이 주어집니다 (1 <= n,m <= 100). 다음 줄에는 n 개의 정수로 A 의 원소들이, 그 다음 줄에는 m 개의 정수로 B 의 원소들이 주어집니다. 모든 원소들은 32비트 부호 있는 정수에 저장할 수 있습니다.

## 출력

각 테스트 케이스마다 한 줄에, JLIS 의 길이를 출력합니다.

## 예제 입력

3  
3 3  
1 2 4  
3 4 7  
3 3  
1 2 3  
4 5 6  
5 3  
10 20 30 1 2  
10 20 30  
## 예제 출력
5  
6  
5  

## 풀이 소스코드  
<script src="https://gist.github.com/overflow218/d093adae029314086f3ed80fd14d4f9b.js"></script>

## 문제 설명
이전에 풀었던 LIS 문제의 확장판이다. 이전에 풀었던 문제와 비슷한 문제를 만났을땐, 그 문제의 핵심 아이디어를 적용해보는 것도 좋은 방법이다. lis문제에서 우리는 lis[i] = i번 인덱스부터 시작하는 LIS의 값으로 정의했다.
이번에는 jlis[i][j] = A[i]와 B[j]에서부터 시작하는 합친 LIS 값이라고 정의해보자. 그러면 max(A[i], B[j])를 만족하는 A[nextA]나 B[nextB] 원소들은 모두 뒤에 올 수 있는 후보가 된다. 이 문제에서 눈여겨볼 점은 
맨 앞에 가상의 음의 무한대 값을 가지는 원소를 넣어줬다는 점이다. 이렇게 함으로써 -1이 아닌 i와 j에 대해, A[i] == B[j]인 상황을 막아줌으로써 뒤에 올 수 있는 원소를 고르기가 쉬워졌다. 마지막에 구한답 -2 를 해주면
우리가 원래 구하려는 값과 같아진다. 

## 문제 출처  

<a href="https://www.algospot.com/judge/problem/read/JLIS"> 문제 링크 </a>
