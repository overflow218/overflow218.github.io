---
layout: post
title: 공항(백준 10775번)
subtitle: 알고리즘 문제풀이
tags: [개발,알고리즘, 탐욕법, 그리디 알고리즘]
comments: true
---    

## 문제 출처  
<a href="https://www.acmicpc.net/problem/10775"> 문제 링크 </a>

## 풀이 소스코드  
<script src="https://gist.github.com/overflow218/84850e06efe2d3180fa05211ab5586f3.js"></script>

## 문제 설명
예제를 몇개 풀어보면 각 비행기마다 gi가 주어졌을때 1 ~ gi 에서 가능한 게이트 중, 가장 큰 번호의 게이트를 골라야한다는 추론을 할 수 있다. 왜냐하면 g1 < g2 일때 2번 비행기가 1번 비행기가 갈 수 있는 게이트로 들어가면 그만큼 1번 비행기는 갈 수 있는 게이트가 좁아지게 된다. 하지만 2번 비행기만 갈 수 있는 g1 + 1 ~ g2 사이에 있는 게이트로 가면 1번 비행기가 갈 수 있는 게이트의 수는 줄어들지 않는다. 여기까지 생각이 왔다면, 이전의 탐욕법 문제들과 같이 탐욕적 선택속성과 최적부분구조를 가지는지를 보여야 한다. 
1. 탐욕적 선택속성  
가능한 게이트 중 번호가 큰 걸 y, 작은 걸 x라고 하자. 이때 y가 아닌 x에 비행기를 놓은 최적해가 있다고 가정하자. x에 있던 비행기를 y로 옮겨보자. 이때 y에 비행기가 있었다면, 그 비행기를 x로 옮기면 되니 문제가 없다. y에 비행기가 없었다면 그냥 비행기만 놓아주면 되므로 역시 문제없다. 또한 어떠한 경우든 나머지 비행기들에는 영향을 미치지 않는다. 따라서 x에 있던 비행기를 y로 옮겨도 최적해가 유지된다. 
2. 최적부분구조
부분문제에서 남은 게이트들을 가지고 비행기를 가장 많이 도킹할 수 있으면 전체 도킹한 비행기수도 많아지므로 최적 부분구조가 성립한다.    




이제 탐욕법으로 풀어도 정당함을 보였으니 탐욕법으로 풀면 된다. 그런데 인풋의 크기가 10만으로 상당히 커서 단순히 하나하나 살펴보면서 가능한 게이트를 찾는 O(n^2) 풀이로는 시간 내에 풀 수 없다. 이렇게 O(n^2)풀이로 힘들때 시간을 줄일 수 있는 한가지 방법이 이분탐색을 활용해 보는 것이다. 그런데 이 문제의 경우 이분탐색으로 푸는 것도 어려움이 있다. 보통 이분탐색에서는 가운데 값의 상태에 따라 큰 쪽을 줄여주거나 작은 쪽을 줄여서 탐색범위를 좁혀 나가는데, 이 문제에선 가운데 값이 사용불가능한 게이트인 경우 큰 쪽을 줄여야할지 작은 쪽을 줄여야할지 알 수 없다. 따라서 최악의 경우엔 똑같이 O(n^2)이 되버린다. 이럴때는 효율적인 다른 자료구조가 있는지 생각해보는 것이 좋다. c++ STL의 set을 생각해보자. set은 완전 이진 트리 구조를 가지고 원소를 추가해줄때마다 자동으로 정렬해준다(O(log N)). 또한 특정 크기 이상의 가장 작은 원소를 찾는 명령 lower_bound() 함수를 제공하는데, 이 역시 O(log N)의 시간이 걸린다. n개의 비행기에 대해 반복해도 O(N log N)이므로 시간안에 충분히 해결가능하다. 위의 소스코드에서 게이트값을 1 ~ n 까지로 놓지않고, -n ~ -1로 놓은 것에 주목하자. set은 기본적으로 오름차순으로 정렬해주는데, 우리의 풀이방법에서는 내림차순 정렬이 필요하다. 앞에 -를 붙여줌으로써 내림차순으로 정렬한 것과 같은 결과를 얻었다.



