---
layout: post
title: 과제(백준 13904번)
subtitle: 알고리즘 문제풀이
tags: [개발,알고리즘, 탐욕법, 그리디 알고리즘]
comments: true
---    

## 문제 출처  
<a href="https://www.acmicpc.net/problem/13904"> 문제 링크 </a>

## 풀이 소스코드  
<script src="https://gist.github.com/overflow218/4ef3aa3a39ad8ddd7aa0a20a492198da.js"></script>

## 문제 설명
처음 보았을때는 어떻게 탐욕법을 써야할지 조금은 막막할 수 있는 문제이다. 제출기한이 작은거부터 더해보자니 최대점수를 맞추기가 힘들고, 점수가 큰거부터 더해보자니 제출기한이 넉넉한데 먼저 더해버려 역시 최대점수를 못 만들게 된다. 한발자국 물러나서 이 문제가 문제가 되는 이유를 생각해보자. 만약 n개의 과제가 주어졌는데 과제마다 제출기한이 다 다르다면 어떻게 될까? 그러면 하루에 과제 하나씩하면 되니까 쉽게 해결할 수 있다. 반대로 제출기한이 겹치는 과제가 있다면? 이제 어떤 과제를 버리고 어떤 과제를 해야할지 생각해야하기 때문에 문제가 어려워진다. 1일부터 시작해보자. 제출기한이 1일인 문제가 하나밖에 없다. 그러면 그거 풀어주면 된다. 제출기한이 2일인 문제가 하나밖에 없다. 그러면 그거 풀어주면 된다. ... 그런데 제출기한이 x일인 문제가 y개가 있다고 하자.
그 문제들을 x1, x2, ... xy라고 하자. 이 문제들은 x일을 넘어가면 점수를 받을 수 없으므로 x일 이전에 처리해야한다. 우리는 현재까지 풀었던 문제의 점수들을 계속 담고 있으니 이전에 풀었던 문제 중에서 x1 보다 점수가 낮은 문제가 있다면 서로 바꿔주면 된다. 이런 방식으로 우리는 1일차까지의 최대점수, 2일차까지의 최대점수 ... 마지막날까지의 최대 점수를 자연스럽게 구할 수 있으므로 문제를 해결할 수 있다. (이 과정에서 자연스럽게 최적부분구조를 보여주었음) 이렇게 탐욕적인 해결법을 찾았으니 정당성만 보여주면 된다. 최적부분구조는 위의 1일차, 2일차 ... 마지막날 과정에서 자연스럽게 보여주었다. 각 일별로 최대 점수를 만들면 전체적으로 최대점수가 되기 때문이다. 탐욕적 선택속성이 성립하는지만 보여주면 된다. 서로 제출기한이 겹치는 문제들이 있을때, 기존 문제들중 점수가 작은것과 바꿔주지 않고 구한 최적해가 있다고 가정하자. 1. 기존 문제들이 모두 겹치는 문제보다 점수가 높은 경우 -> 아무것도 바꿀게 없으니 여전히 최적해다. 2. 기존 문제들 중 겹치는 문제보다 점수가 낮은게 있는 경우 -> 그 문제와 겹치는 문제를 바꿔주면 최적해보다 더 좋은 최적해를 얻을 수 있다. 이를 통해 탐욕적 선택속성이 성립함을 알 수 있다. 


